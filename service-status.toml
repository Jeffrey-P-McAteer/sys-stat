
# Example config file

[general]
# This program is run whenever a [[service]] is checked and the status is different from before.
# A simple template language is supported, such that several constants get replaced
# when used in any string in the command array:
#  {name} = the name section from the [[service]] block
#  {status} = either "good" or "bad". In the future we may also report a "degraded" state.
#  {reason} = any details known about what occurred, for example an http endpoint may report "returned 404 when"
on_status_change = [
  "notify-send", "Service {name} is now {status} because {reason}'",
]
# This program is run after on_status_change when {status} == "good"
on_status_good = [
  "notify-send", "Service {name} has resumed.",
]
# This program is run after on_status_change when {status} == "bad"
on_status_bad = [
  "notify-send", "Service {name} has failed!",
]
# While running service-status prints events to this file in CSV format.
# The plan is to provide details such as service latency which can then
# be graphed to discover when services are likely to break and if they are
# nearing capacity limits.
log_file = "/tmp/status.csv"


# Each [[service]] block is required to have:
#  - name - a unique name for the service
#  - uri - an http, https, or ftp url.
#          More protocols will be added later, but this must
#          describe the host and connection details.
# 
# The rest are optional and default to empty strings or some sane default value

[[service]]
name = "Example dot org"
uri = "http://example.org/"
description = """
  This service responds to http GET requests with a 200 and a document
  containing the phrase "This domain is for use in illustrative examples in documents".
"""
# If the response does not contain this the status becomes "bad"
response_must_contain = "This domain is for use in illustrative examples in documents"
# If the server does not finish replying within this amount of time the status becomes "bad"
response_must_finish_within = "30s"

check_interval = "5m"







